<!DOCTYPE html>
<html>
<head>
    <title>Copenhagen Map with Clustered Points & Clickable Polygons (OSM)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

    <style>
        #map {
            height: 100vh;
            width: 100vw;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        /* Style for the overlay list */
        #polygon-list-container {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000; /* Ensure it's above the map */
            max-height: calc(100% - 20px); /* Limit height to prevent overflow */
            overflow-y: auto; /* Enable scrolling if list is long */
            width: 280px; /* Adjusted width */
            font-family: sans-serif;
            font-size: 14px;
            color: #333;
        }
        #polygon-list-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }
        #polygon-list-container ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #polygon-list-container li {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            cursor: pointer; /* Indicate clickable */
            transition: background-color 0.2s ease;
        }
        #polygon-list-container li:last-child {
            border-bottom: none;
        }
        #polygon-list-container li:hover {
            background-color: #f0f0f0;
        }
        .polygon-name {
            font-weight: bold;
            color: #0056b3;
        }
        .point-count {
            color: #555;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="polygon-list-container">
        <h3>Polygon Point Counts</h3>
        <ul id="polygon-counts-list">
            </ul>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/@mapbox/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

    <script>
        let map;
        let markers; // Marker cluster group for points from filtered_unmet_demand.csv
        let allPointsData = []; // To store parsed point data (lat, lon, other properties) for polygon analysis
        let highlightedPolygon = null; // To keep track of the currently highlighted polygon

        // Define default and highlight styles for polygons
        const defaultPolygonStyle = {
            color: '#0000FF', // Blue border
            weight: 2,
            opacity: 0.7,
            fillColor: '#0000FF', // Blue fill
            fillOpacity: 0.2
        };

        const highlightPolygonStyle = {
            color: '#FF0000', // Red border
            weight: 4,
            opacity: 1,
            fillColor: '#FFFF00', // Yellow fill
            fillOpacity: 0.5
        };

        async function initMap() {
            map = L.map('map').setView([55.6761, 12.5683], 12);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Initialize the MarkerClusterGroup for filtered_unmet_demand.csv points
            markers = L.markerClusterGroup({
                maxClusterRadius: 40 // Experiment with this value (default is 80)
            });
            
            // 1. Load and process the clustered points (from filtered_unmet_demand.csv)
            await addPointsFromCSV();

            // 2. Load the polygons (from merged_polygons.xml)
            await addPolygonsFromKML();

            // 3. Load the bike racks (from cykelstativ.csv) as black dots
            await addBikeRacksFromCSV();
        }

        async function addPointsFromCSV() {
            return new Promise((resolve, reject) => {
                Papa.parse('filtered_unmet_demand.csv', {
                    download: true,
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        const data = results.data;
                        const errors = results.errors;

                        if (errors.length > 0) {
                            console.warn("Papa Parse encountered errors for filtered_unmet_demand.csv:", errors);
                        }

                        data.forEach((row, index) => {
                            const coordinatesString = row['coordinates_search'];
                            
                            if (coordinatesString) {
                                const coordParts = coordinatesString.split(',');
                                if (coordParts.length === 2) {
                                    const lat = parseFloat(coordParts[0]);
                                    const lon = parseFloat(coordParts[1]);
                                    
                                    if (!isNaN(lat) && !isNaN(lon)) {
                                        const marker = L.marker([lat, lon]);
                                        marker.bindPopup(`Coordinates: ${coordinatesString}`);
                                        allPointsData.push({
                                            lat: lat,
                                            lon: lon,
                                            originalRow: row // Keep original row data if you need more info in popup
                                        });
                                        markers.addLayer(marker); // Add marker to the cluster group
                                    } else {
                                        console.warn(`Skipping row ${index + 2} in filtered_unmet_demand.csv: Invalid lat/lon: ${coordinatesString}`);
                                    }
                                } else {
                                    console.warn(`Skipping row ${index + 2} in filtered_unmet_demand.csv: Malformed coordinates: ${coordinatesString}`);
                                }
                            } else {
                                console.warn(`Skipping row ${index + 2} in filtered_unmet_demand.csv: 'coordinates_search' is empty.`);
                            }
                        });

                        map.addLayer(markers);
                        console.log(`Added ${markers.getLayers().length} points from filtered_unmet_demand.csv.`);
                        resolve();
                    },
                    error: function(err) {
                        console.error("Papa Parse error for filtered_unmet_demand.csv:", err);
                        alert("Could not load demand data. Check console for details.");
                        reject(err);
                    }
                });
            });
        }

        // New function to add bike racks from cykelstativ.csv
        async function addBikeRacksFromCSV() {
            return new Promise((resolve, reject) => {
                Papa.parse('cykelstativ.csv', {
                    download: true,
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        const data = results.data;
                        const errors = results.errors;
                        let addedBikeRacks = 0;

                        if (errors.length > 0) {
                            console.warn("Papa Parse encountered errors for cykelstativ.csv:", errors);
                        }

                        data.forEach((row, index) => {
                            const wkbGeometry = row['wkb_geometry'];
                            
                            if (wkbGeometry && wkbGeometry.startsWith('POINT (')) {
                                const coordsMatch = wkbGeometry.match(/\(([^)]+)\)/); // Extracts content inside parentheses
                                if (coordsMatch && coordsMatch[1]) {
                                    const coordParts = coordsMatch[1].split(' ');
                                    if (coordParts.length === 2) {
                                        const lon = parseFloat(coordParts[0]);
                                        const lat = parseFloat(coordParts[1]);
                                        
                                        if (!isNaN(lat) && !isNaN(lon)) {
                                            // Create a black circle marker (dot)
                                            const circle = L.circleMarker([lat, lon], {
                                                radius: 4, // Size of the dot
                                                fillColor: '#000000', // Black fill
                                                color: '#000000', // Black border
                                                weight: 1, // Border thickness
                                                opacity: 1, // Border opacity
                                                fillOpacity: 1 // Fill opacity
                                            }).addTo(map); // Add directly to map, not to cluster group

                                            // Optional: Add a popup with relevant info
                                            circle.bindPopup(`
                                                <b>Stativ Type:</b> ${row['stativ_type'] || 'N/A'}<br>
                                                <b>Placering:</b> ${row['stativ_placering'] || 'N/A'}<br>
                                                <b>Antal Pladser:</b> ${row['antal_pladser'] || 'N/A'}
                                            `);
                                            addedBikeRacks++;
                                        } else {
                                            console.warn(`Skipping row ${index + 2} in cykelstativ.csv: Invalid lat/lon in wkb_geometry: ${wkbGeometry}`);
                                        }
                                    } else {
                                        console.warn(`Skipping row ${index + 2} in cykelstativ.csv: Malformed wkb_geometry format: ${wkbGeometry}`);
                                    }
                                } else {
                                    console.warn(`Skipping row ${index + 2} in cykelstativ.csv: Could not parse coordinates from wkb_geometry: ${wkbGeometry}`);
                                }
                            } else {
                                console.warn(`Skipping row ${index + 2} in cykelstativ.csv: 'wkb_geometry' column is missing or invalid.`);
                            }
                        });

                        console.log(`Added ${addedBikeRacks} bike racks from cykelstativ.csv.`);
                        resolve();
                    },
                    error: function(err) {
                        console.error("Papa Parse error for cykelstativ.csv:", err);
                        alert("Could not load bike rack data. Check console for details.");
                        reject(err);
                    }
                });
            });
        }


        // Function to highlight a polygon layer on the map
        function highlightPolygon(layer) {
            // Reset style of previously highlighted polygon, if any
            if (highlightedPolygon && highlightedPolygon !== layer) {
                highlightedPolygon.setStyle(defaultPolygonStyle);
            }

            // Apply highlight style to the current layer
            layer.setStyle(highlightPolygonStyle);
            highlightedPolygon = layer;

            // Pan and zoom to the highlighted polygon
            map.fitBounds(layer.getBounds(), { padding: [50, 50] }); // Add some padding
        }

        async function addPolygonsFromKML() {
            return new Promise((resolve, reject) => {
                const polygonCountsList = document.getElementById('polygon-counts-list');
                const polygonsForDisplay = []; // Array to store polygon data for sorting

                // CORRECTED: Pass style options as the SECOND argument
                omnivore.kml('merged_polygons.xml', {
                    style: function (feature) {
                        return defaultPolygonStyle; // Apply default style initially
                    }
                })
                .on('ready', function() {
                    this.eachLayer(function(layer) {
                        if (layer instanceof L.Polygon || layer instanceof L.MultiPolygon) {
                            const polygonGeoJSON = layer.toGeoJSON();
                            const polygonName = layer.feature && layer.feature.properties && layer.feature.properties.name 
                                ? layer.feature.properties.name 
                                : 'Unnamed Polygon';

                            let pointsInside = 0;
                            allPointsData.forEach(pointData => {
                                const point = turf.point([pointData.lon, pointData.lat]);
                                if (turf.booleanPointInPolygon(point, polygonGeoJSON)) {
                                    pointsInside++;
                                }
                            });

                            // Store data including the Leaflet layer reference
                            polygonsForDisplay.push({
                                name: polygonName,
                                pointsCount: pointsInside,
                                layer: layer // Store reference to the actual Leaflet layer
                            });

                            // Add existing click listener for map popups
                            layer.on('click', function(e) {
                                const clickedPolygon = e.target;
                                let clickedPointsInside = 0;
                                allPointsData.forEach(pointData => {
                                    const point = turf.point([pointData.lon, pointData.lat]);
                                    if (turf.booleanPointInPolygon(point, clickedPolygon.toGeoJSON())) {
                                        clickedPointsInside++;
                                    }
                                });
                                clickedPolygon.bindPopup(`Points within: <b>${clickedPointsInside}</b>`).openPopup(e.latlng);
                                highlightPolygon(clickedPolygon); // Highlight when clicked on map as well
                            });
                        }
                    });

                    // Sort the polygons by number of points (descending)
                    polygonsForDisplay.sort((a, b) => b.pointsCount - a.pointsCount);

                    // Build and populate the list from the sorted array
                    const fragment = document.createDocumentFragment();
                    polygonsForDisplay.forEach(polygonData => {
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `<span class="polygon-name">${polygonData.name}</span>: <span class="point-count">${polygonData.pointsCount} points</span>`;
                        
                        // Add click listener to the list item
                        listItem.addEventListener('click', () => {
                            highlightPolygon(polygonData.layer); // Call highlight function with the stored layer
                        });
                        fragment.appendChild(listItem);
                    });

                    polygonCountsList.appendChild(fragment);
                    console.log(`Added polygons from KML, sorted list, and configured highlighting.`);
                    resolve();
                })
                .on('error', function(error) {
                    console.error("Error loading KML:", error);
                    alert("Could not load polygon data. Check console for details.");
                    reject(error);
                })
                .addTo(map);
            });
        }

        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>
